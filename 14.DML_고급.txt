1. 서브쿼리(SubQuery)
    1) 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문을 말함
        -하나의 SQL문으로 요구사항을 해결할 수 없는(조금 더 복잡한) 데이터를 추출할 때 사용 
    2) JOIN    
        -조인에 참여하는 모든 테이블이 대등한 관계에 있기 때문에 모든 테이블의 컬럼을 어떤 위치에서라도 
         자유롭게 사용가능
       서브쿼리 
        -서브쿼리는 메인 쿼리의 컬럼을 모두 사용할 수 있음
        -메인 쿼리는 서브 쿼리의 컬럼을 사용할 수 없음
    3) 서브쿼리 사용 시 주의점
        -서브쿼리를 괄호로 감사서 사용함
        -서브쿼리는 단일 행(Single Row) 또는 복수 행(Multiple Row)이 나올 수 있기 때문에
         비교 연산자와 함께 사용 가능
            -단일 행 비교 연산자는 서브쿼리의 결과가 반드시 1건 이하이여야 함
            -복수 행 비교 연산자는 서브쿼리의 결과 건수와 상관이 없음
        -서브쿼리에서는 OREDR BY를 사용하지 못함
            -OREDR BY절은 SELECT절에서 오직 한 개만 올 수 있기 때문에 OREDR BY절은 메인 쿼리의 
             마지막 문자에 위치해야 함 
    4) 서브쿼리가 사용 가능한 위치 
        -SELECT절 - FROM절 - WHERE절 - HAVING절 - OREDR BY절
        -INSERT문의 VALUES절 
        -UPDATE절의 SET절  
    5) 반환 형태에 따른 서브쿼리 분류 
        -단일 행 서브 쿼리 
            -서브 쿼리의 실행 결과가 항상 1건 이하인 서브쿼리를 의미함
            -항상 비교 연산자와 함께 사용됨
            -=, <, <=, >, >=, <> 
        -다중 행 서브 쿼리 
            -서브 쿼리의 실행 결과가 여러 건인 서브쿼리를 의미함
            -다중 행 서브 쿼리는 다중 행 비교 연산자와 함께 사용됨
            -IN, EXISTS 
                -결과값 중에 있는 것 중에서의 의미 
                -IN은 전체 레코드를 스캔하고, EXISTS는 존재여부만 확인하고 스캔하지 않음
                 (EXISTS가 IN보다 상대적으로 속도가 더 빠름)
                -EXISTS 서브쿼리의 조건에 부합하는 레코드가 존재하면 TRUE/존재하지 않으면 FALSE
    6) 사용 위치에 따른 서브쿼리 분류
        -WHERE절: 중첩 서브쿼리 
        -FROM절: 인라인 뷰(FROM절 내에 존재하는 서브쿼리를 인라인 뷰 서브쿼리라고 함)
        -SELECT절: 스칼라 서브쿼리(SELECT절 내에 존재하는 서브쿼리를 스칼라 서브쿼리라고 함)

2. 윈도우 함수(WINDOW FUNCTION)
    1) 행과 행간의 관계에서 다양한 연산 처리를 할 수 있는 함수
    2) 분석함수로도 알려져 있음(ANSI 표준은 윈도우 함수임)
    3) 원도우 함수는 일반 함수와 달리 중첩하여 호출될 수 없음
    4) 종류
        -집계관련 함수
            -COUNT()
            -AVG()
        -순위집계 함수
            -RANK()
            -DENSE_RANK()
            -ROW_NUMBER()
    5) 문법
        SELECT 윈도우함수(인자) OVER (PARTITION BY 컬럼 ORDER BY 컬럼)
        FROM 테이블명
        ;
        -PARTITION BY 
            -FROM절 이하에서 나온 결과집합을 특정 컬럼(들)을 기준으로 그룹화할 수 있음
                -전체 직원 정보를 출력하면서 각 직원이 속한 부서별로 그룹화할 수 있음
    6) 순위집계
        -SELECT RANK() OVER(PARTITION BY [그룹할 컬럼들] ORDER BY [순위를 매길 때 사용할 컬럼들])
         FROM 테이블명 
            -예: 1등(100점), 2등(90점), 3등(85점), 3등(85점), 5등(80점), 6등(79등),...
         -SELECT DENSE_RANK() OVER(PARTITION BY [그룹할 컬럼들] ORDER BY [순위를 매길 때 사용할 컬럼들])
         FROM 테이블명 
            -예: 1등(100점), 2등(90점), 3등(85점), 3등(85점), 4등(80점), 5등(79등),...
         -SELECT ROW_NUMBER() OVER(PARTITION BY [그룹할 컬럼들] ORDER BY [순위를 매길 때 사용할 컬럼들])
         FROM 테이블명 
            -예: 1등(100점), 2등(90점), 3등(85점), 4등(85점), 5등(80점), 6등(79등),...

3. WITH문 활용
    1) SELECT문의 결과를 임시 집합으로 저장해 두고, 
       다른 SQL문에서 마치 테이블처럼 해당 결과를 불러올 수 있음
    2) WITH문을 사용하여 복잡한 SQL문을 단순화 시킬 수 있음
    3) 공통 테이블 표현식(Common Table Expression)이라고도 함 
    4) WITH문 내에 존재하는 SELECT문의 결과집합이 하나의 뷰가 됨
        -그 뷰의 이름은 WITH문의 명칭임

4. 계층형 SQL문 
    0) with문을 이용하여 재귀(본디의 곳으로 다시 돌아오는 것->자기자신) 쿼리를 작성
        -데이터 값 기준 부모 자식 간의 관계를 표현
    1) 순방향(위에서 아래로) 전개
    2) 역방향(아래에서 위로) 전개
    3) 문법
        WITH RECURSIVE WITH테이블명 AS (
            SELECT문
            UNION
            SELECT문                           --반복 쿼리 부분
        )
        SELECT * FROM WITH테이블명 ;            --부모쿼리
    4) 문자열 함수
        -SUBSTRING(string, int, int)
        -LPAD(string, n, string) / RPAD(string, n, string)
            -첫번째 명시한 문자열에 길이가 n이 되도록 좌측부터 세번째 명시한 문자열로 채운 표현식을 반환